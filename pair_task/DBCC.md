# Database Core Concepts: Transactions, Integrity, and Concurrency Control

## 트랜잭션과 ACID

트랜잭션은 쉽게 말해서 "하나의 작업 단위"입니다. 보통 많이 예로 드는 은행 송금 케이스의 경우, A 계좌에서 돈을 인출되고 그 돈이 B 계좌에 입금 되는 두 작업은 반드시 같이 성공하거나 같이 실패해야 합니다. 이것이 트랜잭션의 이해하기 쉬운 가장 좋은 예입니다.

### Atomicity (원자성)
"전부 성공 또는 전부 실패"라고 하는 말이 가장 유명합니다. 트랜잭션 안의 작업들은 모두 성공하거나, 하나라도 실패하면 전부 취소됩니다. 송금 중에 시스템이 뻗으면 A 계좌에서 돈 빠진 것도 원래대로 돌아갑니다. 송금을 시작했어도 완료 과정까지 모두 성공하지 않으면 롤백되어 모두 실패하는 구조를 가집니다.

### Consistency (일관성)
트랜잭션 전후로 데이터베이스가 언제나 항상 유효한 상태여야 합니다. 예를 들어 "잔액은 음수가 될 수 없다."는 규칙이 있으면, 트랜잭션 후에도 이 규칙은 반드시 지켜져야 합니다. 

### Isolation (고립성)
여러 트랜잭션이 동시에 실행되더라도 서로 간섭하면 안 됩니다. 예를 들어 모바일앱에서의 요청과 웹에서의 요청은 서로 간섭하지 않습니다. 마치 각 트랜잭션이 혼자서 실행되는 것처럼 보여야 합니다. 실무에서는 성능 때문에 격리 수준(Isolation Level)을 조절하기도 합니다.

### Durability (지속성)
한 번 커밋된 트랜잭션은 시스템이 off되어도 절대 사라지지 않아야 합니다.. 데이터베이스가 디스크에 기록하기 때문입니다.

`BEGIN`, `COMMIT`, `ROLLBACK` 명령어로 트랜잭션을 제어합니다. 대부분의 프레임워크에서는 `@Transactional` 같은 어노테이션으로 자동 관리하기도 합니다.

---

## 무결성 (Integrity)

무결성은 "데이터가 정확하고 일관성 있게 유지되는 것"을 말합니다. 필요없는 쓸데없는 데이터가 들어가지 않도록 막는 규칙들입니다.

### 엔티티 무결성 (PK)
모든 테이블에는 각 행을 유일하게 식별할 수 있는 기본키(Primary Key)가 있어야 하고, 이 값은 NULL이 될 수 없습니다. 학번이 없는 학생, 주문번호가 없는 주문이 있을 수 없습니다. 사람의 주민등록번호와 같습니다.

### 참조 무결성 (FK)
외래키(Foreign Key)는 다른 테이블의 기본키를 참조하는데, 존재하지 않는 값을 참조해서는 안됩니다.. 예를 들어 order 테이블에서 user_id가 1인 주문이 있는데, 고객 테이블에 1번 고객이 없으면 문제가 됩니다.

실무에서 부모 데이터 삭제 시 처리 방법은 다음과 같습니다:
- `CASCADE`: 부모를 삭제하면 자식도 같이 삭제됩니다. 예를 들어 상품 리뷰의 경우 유저가 탈퇴하면 리뷰도 함께 사라지도록 합니다.
- `SET NULL`: 부모를 삭제하면 자식의 외래키를 NULL로 설정합니다. 이럴 경우는 유저의 리뷰를 데이터분석 차원 등에 활용하기 위해 남겨둡니다.
- `RESTRICT`: 자식이 있으면 부모를 삭제할 수 없습니다. 이는 자식을 먼저 삭제하고 부모를 삭제하는 과정을 거쳐야 완료할 수 있습니다.

### 도메인 무결성 (데이터 타입, 제약조건)
각 컬럼에 들어갈 수 있는 값의 범위를 제한합니다. 나이 컬럼은 정수형인데 문자열이 들어가거나, 음수인 나이가 들어갈 수 없습니다. 이때 `CHECK`, `NOT NULL`, `UNIQUE` 같은 제약조건으로 관리할 수 있습니다.

### 사용자 정의 무결성 (규칙/트리거)
로직에 따른 규칙입니다. "재고보다 많이 주문할 수 없다", "기 구매 고객만 추가주문 가능" 같은 것들이 있습니다. 트리거(Trigger)나 애플리케이션 로직으로 구현할 수 있습니다.

---

## 동시성 제어 (Concurrency Control)

데이터베이스는 여러 사용자가 동시에 접근하는 경우도 있습니다. 동시성 제어가 없으면 같은 데이터를 동시에 수정할 때 엉망이 됩니다. 모바일과 웹에서 동시에 출금 요청을 할 경우 제어가 없으면 둘 다 성공해 버리게 되면 큰 문제가 발생합니다.

### Lock (락) 기반 동시성 제어
가장 기본적인 방법으로 데이터를 사용할 때 잠금을 걸어서 다른 트랜잭션이 접근하지 못하게 합니다.

- **공유 락 (Shared Lock, S-Lock)**: 여러 트랜잭션이 동시에 읽기 가능합니다.
- **배타 락 (Exclusive Lock, X-Lock)**: 락을 먼저 잡은 트랜잭션만 접근 가능합니다.

### MVCC (다중 버전 동시성 제어)
락의 단점을 보완한 방식으로써 데이터를 수정하면 버전을 새롭게 만들고, 읽는 쪽은 이전 버전을 봅니다. PostgreSQL, MySQL InnoDB 등 대부분의 현대 DB가 이 방식을 사용합니다.

### 낙관적 vs 비관적 동시성 제어

**비관적 (Pessimistic)**
- 데이터 접근 전에 먼저 락을 걸게 됩니다.
- 이때 충돌은 확실히 막지만, 대기 시간이 발생합니다.
- `SELECT ... FOR UPDATE` 같은 구문을 사용합니다.

**낙관적 (Optimistic)**
- 락 없이 일단 작업하고, 커밋 확정 시 충돌 여부를 확인합니다.
- 충돌 시 롤백하고 재시도합니다.
- 버전 번호나 타임스탬프로 충돌을 감지합니다.
- 읽기가 많고 쓰기가 적은 환경에 적합합니다.

### Deadlock (데드락) 관리
두 트랜잭션이 서로가 가진 락을 기다리면서 영원히 멈춰버리는 상황입니다.
DB는 이를 감지하면 한쪽 트랜잭션을 강제로 롤백시킵니다.

**예방 방법:**
- 락 획득 순서를 항상 동일하게 유지합니다
- 트랜잭션을 짧게 유지합니다
- 락 타임아웃을 설정합니다
